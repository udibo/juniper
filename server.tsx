/**
 * This module is used for creating the server side entrypoint for Juniper applications.
 * This is for internal use only. It is used in the generated `main.ts` file.
 *
 * @module
 */
import { Hono } from "hono";
import type { Env, Schema } from "hono";
import { createFactory, createMiddleware } from "hono/factory";
import { stream } from "hono/streaming";
import { serveStatic } from "hono/deno";
import { trimTrailingSlash } from "hono/trailing-slash";
import * as path from "@std/path";
import { HttpError } from "@udibo/http-error";
import { getInstance } from "@udibo/juniper/utils/otel";
import { isDevelopment } from "@udibo/juniper/utils/env";
import {
  createStaticHandler,
  createStaticRouter,
  StaticRouterProvider,
  unstable_RouterContextProvider,
} from "react-router";
import type { RouteObject } from "react-router";
import { StrictMode } from "react";
import { renderToReadableStream } from "react-dom/server";
import reactHelmetAsync from "react-helmet-async";
const { HelmetProvider } = reactHelmetAsync;
import type { HelmetServerState } from "react-helmet-async";

import type { Client, Routes as ClientRoutes } from "./client.tsx";

const notFound = createMiddleware(() => {
  throw new HttpError(404, "Not found");
});

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createApp } from "@udibo/juniper/server";
 *
 * const routes: Routes = {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ]
 * };
 * ```
 */
export interface Routes<
  E extends Env = Env,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: { default?: Hono<E, S, BasePath> };
  /** Optional index route handler (handles exact path matches) */
  index?: { default?: Hono<E, S, BasePath> };
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: { default?: Hono<E, S, BasePath> };
  /** Optional array of child routes */
  children?: Routes<E, S, BasePath>[];
}

// TODO: Learn more about the context object.
// TODO: Add loader and action to server and client routes. Learn how they impact the context.
// TODO: Test having loader on both layout and child routes. How are loaders handled with multiple layers?
// TODO: Update this to use react helmet and setup document start/end correctly
/**
 * Creates handlers for React Router.
 *
 * This function is used to create handlers for React Router.
 *
 * @param routes - The routes to create handlers for
 * @returns The handlers for the routes
 */
function createHandlers(routes: RouteObject[]) {
  const factory = createFactory();
  const { query, dataRoutes, queryRoute } = createStaticHandler(routes);

  return factory.createHandlers(
    async function handleDocumentRequest(c, next) {
      if (c.req.header("accept")?.includes("application/json")) {
        return next();
      }

      // TODO: Change where this is created so that it can be used by server middleware.
      const requestContext = new unstable_RouterContextProvider();
      const context = await query(c.req.raw, {
        requestContext,
      });

      if (context instanceof Response) {
        return context;
      }

      const router = createStaticRouter(dataRoutes, context);

      const helmetContext = { helmet: {} as HelmetServerState };
      const renderStream = await renderToReadableStream(
        <StrictMode>
          <HelmetProvider context={helmetContext}>
            <StaticRouterProvider router={router} context={context} />
          </HelmetProvider>
        </StrictMode>,
      );
      await renderStream.allReady;

      const deepestMatch = context.matches[context.matches.length - 1];
      const actionHeaders = context.actionHeaders[deepestMatch.route.id];
      const loaderHeaders = context.loaderHeaders[deepestMatch.route.id];

      for (const [key, value] of actionHeaders?.entries() ?? []) {
        c.header(key, value);
      }
      for (const [key, value] of loaderHeaders?.entries() ?? []) {
        c.header(key, value);
      }

      c.header("Content-Type", "text/html; charset=utf-8");
      return stream(c, async (stream) => {
        await stream.writeln("<!DOCTYPE html>");
        const { helmet } = helmetContext;
        await stream.writeln(`<html ${helmet.htmlAttributes.toString()}>`);
        await stream.writeln("  <head>");
        await stream.writeln(`    ${helmet.base.toString()}`);
        await stream.writeln(`    ${helmet.title.toString()}`);
        await stream.writeln(`    ${helmet.priority.toString()}`);
        await stream.writeln(`    ${helmet.meta.toString()}`);
        await stream.writeln(`    ${helmet.link.toString()}`);
        await stream.writeln(`    ${helmet.style.toString()}`);
        await stream.writeln(`    ${helmet.script.toString()}`);
        await stream.writeln(`    ${helmet.noscript.toString()}`);
        await stream.writeln(
          `    <script type="module" src="/build/main.js" defer></script>`,
        );
        if (isDevelopment()) {
          await stream.writeln(
            `    <script src="/dev-client.js" defer></script>`,
          );
        }
        await stream.writeln("  </head>");
        await stream.writeln(`  <body ${helmet.bodyAttributes.toString()}>`);
        await stream.write(`    <div id="root">`);
        await stream.pipe(renderStream);
        await stream.writeln("</div>");
        await stream.writeln("  </body>");
        await stream.writeln("</html>");
      });
    },
    async function handleDataRequest(c) {
      const data = await queryRoute(c.req.raw);
      return c.json(data);
    },
  );
}

/**
 * Builds a Hono application by combining client and server routes.
 *
 * The logic is:
 * - If only server routes exist: use them as-is
 * - If only client routes exist: add React handlers for document requests
 * - If both exist: server routes run first (middleware), then client handlers for document requests
 *
 * @param serverRoutes - The server route configuration
 * @param clientRoutes - The client route configuration
 * @param reactHandlers - The React Router handlers for rendering pages
 * @param projectRoot - Optional project root for static file serving
 * @returns A configured Hono application
 */
function buildApp<
  E extends Env,
  S extends Schema,
  BasePath extends string,
>(
  serverRoutes: Routes<E, S, BasePath>,
  clientRoutes: ClientRoutes,
  reactHandlers: ReturnType<typeof createHandlers>,
  projectRoot?: string,
): Hono<E, S, BasePath> {
  // Start with server's main app or create new one
  const app = serverRoutes.main?.default ?? new Hono<E, S, BasePath>();

  // Add React handlers for main route if client route exists
  if (!clientRoutes.index && clientRoutes.main) {
    app.get("/", ...reactHandlers);
    app.post("/", ...reactHandlers);
  }

  // Handle index routes
  if (clientRoutes.index || serverRoutes.index) {
    const indexApp = serverRoutes.index?.default ?? new Hono<E, S, BasePath>();
    if (clientRoutes.index) {
      indexApp.get("/", ...reactHandlers);
      indexApp.post("/", ...reactHandlers);
    }
    app.route("/", indexApp);
  }

  // Handle catchall routes
  if (clientRoutes.catchall || serverRoutes.catchall) {
    const catchallApp = serverRoutes.catchall?.default ??
      new Hono<E, S, BasePath>();
    if (clientRoutes.catchall) {
      catchallApp.get("/:*{.+}", ...reactHandlers);
      catchallApp.post("/:*{.+}", ...reactHandlers);
      catchallApp.get("*", ...reactHandlers);
      catchallApp.post("*", ...reactHandlers);
    }
    app.route("/:*{.+}", catchallApp);
    app.route("*", catchallApp);
  }

  // Handle children routes
  const allChildPaths = new Set([
    ...(serverRoutes.children || []).map((r) => r.path),
    ...(clientRoutes.children || []).map((r) => r.path),
  ]);

  for (const childPath of allChildPaths) {
    const serverChild = serverRoutes.children?.find((r) =>
      r.path === childPath
    );
    const clientChild = clientRoutes.children?.find((r) =>
      r.path === childPath
    );

    if (serverChild || clientChild) {
      const childApp = buildApp(
        serverChild || { path: childPath as BasePath },
        clientChild || { path: childPath },
        reactHandlers,
      );
      app.route(childPath, childApp);
    }
  }

  // Add static file serving if this is the root
  if (projectRoot) {
    // Workaround for Hono Windows issue: use simple relative path from cwd
    const cwd = Deno.cwd();
    let publicPath = path.resolve(projectRoot, "./public");
    const relativePath = path.relative(cwd, publicPath);

    // Ensure forward slashes on Windows for Hono compatibility
    publicPath = Deno.build.os === "windows"
      ? relativePath.replace(/\\/g, "/")
      : relativePath;

    // Serve dev client script in development mode
    if (isDevelopment()) {
      const devClientPath = path.fromFileUrl(
        import.meta.resolve("./dev-client.js"),
      );
      const devClientContent = Deno.readTextFileSync(devClientPath);
      app.get("/dev-client.js", (c) => {
        return c.body(devClientContent, 200, {
          "Content-Type": "application/javascript",
        });
      });
    }

    // Note: There's a known issue with Hono's serveStatic on Windows (https://github.com/honojs/hono/issues/3475)
    // This workaround attempts to work around path separator and relative path issues
    app.get(
      "*",
      serveStatic({
        root: publicPath,
      }),
    );
  }

  app.use("*", notFound);
  return app;
}

/**
 * Creates a Hono application server with the provided route configuration.
 * The main entrypoint that uses this function is automatically generated by the build script.
 *
 * This function sets up error handling, trailing slash trimming, static file serving,
 * and builds the complete route tree from the provided configuration, merging both
 * client and server routes.
 *
 * @example Creating an application
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ]
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @param moduleUrl - The URL of the module creating the server
 * @param client - The client configuration
 * @param routes - The server route configuration object
 * @returns A configured Hono application instance
 */
export function createServer<
  E extends Env = Env,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  moduleUrl: string,
  client: Client,
  routes: Routes<E, S, BasePath>,
): Hono<E, S, BasePath> {
  const projectRoot = path.dirname(path.fromFileUrl(moduleUrl));
  const appWrapper = new Hono<E, S, BasePath>({ strict: true });

  appWrapper.onError((cause) => {
    const error = HttpError.from(cause);
    if (!error.instance) {
      const instance = getInstance();
      if (instance) {
        error.instance = instance;
      }
    }
    console.error(error);
    return error.getResponse();
  });
  appWrapper.use(trimTrailingSlash());

  // TODO: Override client routes actions and loaders with server routes actions and loaders
  // Initially manually override the client routes actions and loaders with server routes actions and loaders.
  // Then after learning how they work automate it.
  // client routes use lazy, need to unlazy them to replace the actions and loaders
  // By unlazy, I mean the server will await the lazy function, replacing it on the route with it's contents.
  // But the loader and action will be replaced with the server routes actions and loaders.
  const clientRoutes = client.routes;
  const handlers = createHandlers(clientRoutes);
  const app = buildApp(routes, client.appRoutes, handlers, projectRoot);

  appWrapper.route("/", app);
  return appWrapper;
}
