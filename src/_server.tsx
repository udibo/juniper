import * as path from "@std/path";
import { parseArgs } from "@std/cli/parse-args";
import { HttpError } from "@udibo/http-error";
import { SpanStatusCode } from "@opentelemetry/api";
import { Hono } from "hono";
import type { Env, Schema } from "hono";
import { createFactory } from "hono/factory";
import { serveStatic } from "hono/deno";
import { stream } from "hono/streaming";
import type { StatusCode } from "hono/utils/http-status";
import type {
  ActionFunctionArgs,
  HydrationState,
  LoaderFunctionArgs,
} from "react-router";
import {
  createStaticHandler,
  createStaticRouter,
  StaticRouterProvider,
} from "react-router";
import type { RouterContextProvider } from "react-router";
import type { RouteObject } from "react-router";
import { StrictMode, Suspense, use } from "react";
import { renderToReadableStream } from "react-dom/server";
import serialize from "serialize-javascript";
import SuperJSON from "superjson";
import { isbot } from "isbot";

import type {
  ClientRoute,
  HydrationData,
  SerializedError,
} from "@udibo/juniper/client";
import { isDevelopment } from "@udibo/juniper/utils/env";
import { getInstance } from "@udibo/juniper/utils/otel";

import {
  App,
  type SerializedHydrationData,
  type SerializedHydrationDataPromises,
} from "./_client.tsx";
import { startActiveSpan } from "./utils/_otel.ts";
import type { ActionFunction, LoaderFunction } from "@udibo/juniper";

const args = parseArgs(Deno.args, {
  boolean: ["hot-reload"],
});

/**
 * The default environment type for the Juniper application.
 */
export type AppEnv = Env & {
  Variables: {
    context: RouterContextProvider;
  };
};

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 * import { client } from "./main.tsx";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ],
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 */
interface ServerRouteModule {
  // deno-lint-ignore no-explicit-any -- Accepts any Hono app regardless of its type parameters
  default?: Hono<any, any, any>;
  loader?: LoaderFunction;
  action?: ActionFunction;
}

interface ServerMainRouteModule extends ServerRouteModule {
  serializeError?: (error: unknown) => SerializedError | unknown;
  publicEnvKeys?: string[];
}

export const DEFAULT_PUBLIC_ENV_KEYS = ["APP_NAME", "APP_ENV", "NODE_ENV"];

export interface Route<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: ServerMainRouteModule;
  /** Optional index route handler (handles exact path matches) */
  index?: ServerRouteModule;
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: ServerRouteModule;
  /** Optional array of child routes */
  children?: Route<E, S, BasePath>[];
}

/**
 * Serializes an error to a serialized error.
 * The default serialize error function supports HttpError, Error, and global Error subclasses like TypeError.
 *
 * @param error - The error to serialize.
 * @returns The serialized error.
 */
export function serializeErrorDefault(
  error: unknown,
): SerializedError | unknown {
  let serializedError: SerializedError | unknown = error;
  if (error instanceof Error) {
    if (error instanceof HttpError) {
      if (!error.instance) error.instance = getInstance();
      serializedError = {
        __type: "Error",
        __subType: "HttpError",
        ...error.toJSON(),
      };
    } else {
      serializedError = { __type: "Error" };
      if (error.name !== "Error") {
        (serializedError as SerializedError).__subType = error.name;
      }
      (serializedError as SerializedError).message = error.message;
    }
    if (isDevelopment()) {
      (serializedError as SerializedError).stack = error.stack;
    }
  }
  return serializedError;
}

/**
 * Processes a single route data object, resolving any Promises and tracking
 * which keys were resolved or rejected for later reconstruction.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
async function processRouteData(
  routeData: Record<string, unknown>,
  serializeError?: (error: unknown) => unknown,
): Promise<{
  resolvedData: Record<string, unknown>;
  resolvedKeys: string[];
  rejectedKeys: string[];
}> {
  const resolvedData: Record<string, unknown> = {};
  const resolvedKeys: string[] = [];
  const rejectedKeys: string[] = [];

  for (const [key, value] of Object.entries(routeData)) {
    if (value instanceof Promise) {
      try {
        const resolvedValue = await Promise.resolve(value);
        resolvedData[key] = resolvedValue;
        resolvedKeys.push(key);
      } catch (error) {
        resolvedData[key] = serializeError?.(error) ??
          serializeErrorDefault(error);
        rejectedKeys.push(key);
      }
    } else {
      resolvedData[key] = value;
    }
  }

  return { resolvedData, resolvedKeys, rejectedKeys };
}

/**
 * Serializes hydration data by resolving all Promises and tracking their states.
 * Returns both the serialized data and metadata about which promises were resolved/rejected.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
export async function serializeHydrationData(
  hydrationData: HydrationData,
  options: {
    serializeError?: (error: unknown) => unknown;
  } = {},
): Promise<SerializedHydrationData> {
  const { serializeError } = options;
  const resolved: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };
  const rejected: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };

  const { publicEnv, matches } = hydrationData;

  // Serialize errors
  let errors: HydrationState["errors"];
  if (hydrationData.errors) {
    errors = {};
    for (const [key, serializedError] of Object.entries(hydrationData.errors)) {
      errors[key] = serializeError?.(serializedError) ??
        serializeErrorDefault(serializedError);
    }
  }

  // Process loader data
  let loaderData: HydrationState["loaderData"];
  if (hydrationData.loaderData) {
    loaderData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.loaderData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      loaderData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.loaderData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.loaderData![routeId] = rejectedKeys;
      }
    }
  }

  // Process action data
  let actionData: HydrationState["actionData"];
  if (hydrationData.actionData) {
    actionData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.actionData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      actionData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.actionData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.actionData![routeId] = rejectedKeys;
      }
    }
  }

  const { json, meta } = SuperJSON.serialize({
    matches,
    errors,
    loaderData,
    actionData,
  });

  return {
    json,
    meta,
    publicEnv,
    resolved,
    rejected,
  };
}

function HydrationScript(
  { serializedHydrationData }: { serializedHydrationData: Promise<string> },
) {
  const hydrateScript = use(serializedHydrationData);
  return (
    <script
      type="module"
      suppressHydrationWarning
      dangerouslySetInnerHTML={{ __html: hydrateScript }}
    />
  );
}

/**
 * Gathers public environment variables to share with the client.
 *
 * @param allPublicEnvKeys - All environment variable keys to include
 * @returns An object containing the public environment variables
 */
function getPublicEnv(allPublicEnvKeys: string[]): Record<string, string> {
  const publicEnv: Record<string, string> = {};
  for (const key of allPublicEnvKeys) {
    const value = Deno.env.get(key);
    if (value !== undefined) {
      publicEnv[key] = value;
    }
  }
  return publicEnv;
}

function serverLoaderError() {
  throw new Error("Cannot call serverLoader from server");
}

function serverActionError() {
  throw new Error("Cannot call serverAction from server");
}

type LazyRouteFunction = () => Promise<
  Omit<RouteObject, "children" | "index" | "path">
>;

function wrapLazyToStripLoaderAndAction(
  lazy: RouteObject["lazy"],
): RouteObject["lazy"] {
  if (!lazy || typeof lazy !== "function") return lazy;

  const lazyFn = lazy as LazyRouteFunction;
  const wrappedLazy: LazyRouteFunction = async () => {
    const { loader: _loader, action: _action, ...rest } = await lazyFn();
    return rest;
  };
  return wrappedLazy as RouteObject["lazy"];
}

/**
 * Merges server routes with client route objects, replacing client loaders/actions
 * with server-side implementations where available. Client loaders/actions are always
 * stripped from the route objects since they are only used for client-side navigation.
 *
 * @param serverRoute - The server route configuration
 * @param clientRoutes - The client route objects from React Router
 * @returns The merged route objects with server loaders/actions
 */
export function mergeServerRoutes<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoutes: RouteObject[],
): RouteObject[] {
  function applyServerModule(
    routeObj: RouteObject,
    serverModule: Pick<ServerRouteModule, "loader" | "action"> | undefined,
  ): void {
    delete routeObj.loader;
    delete routeObj.action;
    routeObj.lazy = wrapLazyToStripLoaderAndAction(routeObj.lazy);

    if (serverModule?.loader) {
      const serverLoader = serverModule.loader;
      routeObj.loader = async (args: LoaderFunctionArgs) => {
        const { context, params, request } = args;
        return await serverLoader({
          context,
          params,
          request,
          serverLoader: serverLoaderError,
        });
      };
    }
    if (serverModule?.action) {
      const serverAction = serverModule.action;
      routeObj.action = async (args: ActionFunctionArgs) => {
        const { context, params, request } = args;
        return await serverAction({
          context,
          params,
          request,
          serverAction: serverActionError,
        });
      };
    }
  }

  function processRouteObjects(
    serverRouteNode: Route<E, S, BasePath> | undefined,
    clientObjs: RouteObject[],
  ): RouteObject[] {
    return clientObjs.map((clientObj) => {
      const newRouteObj: RouteObject = { ...clientObj };

      if (clientObj.index) {
        applyServerModule(newRouteObj, serverRouteNode?.index);
      } else if (clientObj.path === "*") {
        applyServerModule(newRouteObj, serverRouteNode?.catchall);
      } else {
        applyServerModule(newRouteObj, serverRouteNode?.main);
      }

      if (clientObj.children && clientObj.children.length > 0) {
        const childServerRoutes = serverRouteNode?.children ?? [];
        newRouteObj.children = clientObj.children.map((childClientObj) => {
          const matchingServerChild = childServerRoutes.find((sr) => {
            if (childClientObj.index) {
              return sr.path === clientObj.path && sr.index !== undefined;
            }
            if (childClientObj.path === "*") {
              return sr.path === "*" || sr.catchall !== undefined;
            }
            return sr.path === childClientObj.path;
          });

          if (childClientObj.index) {
            const serverIndex = matchingServerChild?.index ??
              serverRouteNode?.index;
            const indexRoute: RouteObject = { ...childClientObj };
            applyServerModule(indexRoute, serverIndex);
            return indexRoute;
          } else if (childClientObj.path === "*") {
            const serverCatchall = matchingServerChild?.catchall ??
              serverRouteNode?.catchall;
            const catchallRoute: RouteObject = { ...childClientObj };
            applyServerModule(catchallRoute, serverCatchall);
            return catchallRoute;
          }

          if (matchingServerChild) {
            return processRouteObjects(matchingServerChild, [
              childClientObj,
            ])[0];
          }

          const noServerRoute: RouteObject = { ...childClientObj };
          applyServerModule(noServerRoute, undefined);
          if (childClientObj.children) {
            noServerRoute.children = processRouteObjects(
              undefined,
              childClientObj.children,
            );
          }
          return noServerRoute;
        });
      }

      return newRouteObj;
    });
  }

  return processRouteObjects(serverRoute, clientRoutes);
}

/**
 * Creates handlers for React Router.
 *
 * This function is used to create handlers for React Router.
 *
 * @param route - The route configuration
 * @param routes - The routes to create handlers for
 * @returns The handlers for the routes
 */
export function createHandlers<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>, routes: RouteObject[]) {
  const factory = createFactory<AppEnv>();
  const serializeError = route.main?.serializeError ?? (() => {});
  const allPublicEnvKeys = [
    ...new Set([
      ...DEFAULT_PUBLIC_ENV_KEYS,
      ...(route.main?.publicEnvKeys ?? []),
    ]),
  ];
  const { query, dataRoutes, queryRoute } = createStaticHandler(routes);

  return factory.createHandlers(
    async function handleDocumentRequest(c, next) {
      return await startActiveSpan("handleDocumentRequest", async (_span) => {
        if (c.req.header("accept")?.includes("application/json")) {
          return next();
        }

        const requestContext = c.get("context");
        const contextOrResponse = await startActiveSpan(
          "query",
          async (_querySpan) => {
            return await query(c.req.raw, {
              requestContext,
            });
          },
        );

        if (contextOrResponse instanceof Response) {
          return contextOrResponse;
        }
        const context = contextOrResponse;

        const router = createStaticRouter(dataRoutes, context);

        let renderStream: ReturnType<typeof renderToReadableStream>;
        let aborted = false;
        let renderAttempts = 0;
        async function render() {
          renderAttempts += 1;
          let retry = false;
          await startActiveSpan("render.attempt", async (renderAttemptSpan) => {
            renderAttemptSpan.setAttribute(
              "render.attempt.index",
              renderAttempts,
            );
            try {
              const hydrationData = {
                publicEnv: getPublicEnv(allPublicEnvKeys),
                matches: context.matches.map((match) => ({
                  id: match.route.id,
                })),
                errors: context.errors,
                loaderData: context.loaderData,
                actionData: context.actionData,
              };
              const serializedHydrationData = serializeHydrationData(
                hydrationData,
                { serializeError },
              ).then((data) =>
                `import { client } from "/build/main.js"; window.__juniperHydrationData = ${
                  serialize(data, { isJSON: true })
                }; await client.hydrate();`
              );
              const bootstrapScripts: string[] = [];
              if (args["hot-reload"]) {
                bootstrapScripts.push("/dev-client.js");
              }

              renderStream = await renderToReadableStream(
                <StrictMode>
                  <App>
                    <StaticRouterProvider
                      router={router}
                      context={context}
                      hydrate={false}
                    />
                    <Suspense fallback={null}>
                      <HydrationScript
                        serializedHydrationData={serializedHydrationData}
                      />
                    </Suspense>
                  </App>
                </StrictMode>,
                {
                  bootstrapModules: ["/build/main.js"],
                  bootstrapScripts,
                  signal: c.req.raw.signal,
                  onError: (error: unknown) => {
                    const abortError = error instanceof Error &&
                      error.name === "AbortError";
                    if (aborted && abortError) return;
                    console.error("render onError", error);
                    if (abortError) {
                      aborted = true;
                    }
                  },
                },
              );
              if (isbot(c.req.header("user-agent"))) {
                await renderStream.allReady;
              }
            } catch (error) {
              if (
                c.req.raw.signal.aborted ||
                (error instanceof Error && error.name === "AbortError")
              ) {
                throw error;
              }
              if (!context.errors) context.errors = {};
              if (
                context._deepestRenderedBoundaryId &&
                !(context._deepestRenderedBoundaryId in context.errors)
              ) {
                context.errors[context._deepestRenderedBoundaryId] = error;
                retry = true;
              } else {
                throw error;
              }
            }
          });
          if (retry) {
            await render();
          }
        }
        await startActiveSpan("render", async (renderSpan) => {
          await render();
          renderSpan.setAttribute("render.attempt.count", renderAttempts);
        });

        const deepestMatch = context.matches[context.matches.length - 1];
        const actionHeaders = context.actionHeaders[deepestMatch.route.id];
        const loaderHeaders = context.loaderHeaders[deepestMatch.route.id];

        const statusCode: StatusCode = Object.values(context.errors ?? {})
          .find((value: unknown) =>
            value instanceof Error && (value as HttpError).status
          )
          ?.status ??
          context.statusCode ??
          200;

        c.status(statusCode);

        for (const [key, value] of actionHeaders?.entries() ?? []) {
          c.header(key, value);
        }
        for (const [key, value] of loaderHeaders?.entries() ?? []) {
          c.header(key, value);
        }

        c.header("Content-Type", "text/html; charset=utf-8");
        c.header("Vary", "Accept");
        return stream(c, async (streamInstance) => {
          return await startActiveSpan("stream.pipe", async (streamSpan) => {
            try {
              await streamInstance.pipe(renderStream);
            } catch (cause) {
              if (typeof cause === "undefined" && c.req.raw.signal.aborted) {
                streamSpan.setStatus({
                  code: SpanStatusCode.ERROR,
                  message: "Stream aborted",
                });
              } else {
                throw cause;
              }
            }
          });
        });
      });
    },
    async function handleDataRequest(c) {
      return await startActiveSpan("handleDataRequest", async (_span) => {
        const routeId = c.req.header("X-Juniper-Route-Id");

        const requestContext = c.get("context");
        const dataOrResponse = await queryRoute(c.req.raw, {
          requestContext,
          routeId,
        });

        c.header("Vary", "Accept");
        if (dataOrResponse instanceof Response) {
          const location = dataOrResponse.headers.get("Location");
          if (
            dataOrResponse.status >= 300 && dataOrResponse.status < 400 &&
            location
          ) {
            c.header("X-Juniper", "redirect");
            return c.json({ location });
          }
          return dataOrResponse;
        }

        c.header("X-Juniper", "serialized");
        return c.json(SuperJSON.serialize(dataOrResponse));
      });
    },
  );
}

/**
 * Builds a Hono application by combining client and server routes.
 *
 * The logic is:
 * - If only server routes exist: use them as-is
 * - If only client routes exist: add React handlers for document requests
 * - If both exist: server routes run first (middleware), then client handlers for document requests
 *
 * @param serverRoute - The server route configuration
 * @param clientRoute - The client route configuration
 * @param reactHandlers - The React Router handlers for rendering pages
 * @param projectRoot - Optional project root for static file serving
 * @returns A configured Hono application
 */
export function buildApp<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoute: ClientRoute,
  reactHandlers: ReturnType<typeof createHandlers>,
  projectRoot?: string,
): Hono<E, S, BasePath> {
  const notFound = createFactory().createMiddleware(() => {
    throw new HttpError(404, "Not found");
  });

  const app = (serverRoute.main?.default ?? new Hono()) as Hono<E, S, BasePath>;

  if (!clientRoute.index && clientRoute.main) {
    app.get("/", ...reactHandlers);
    app.post("/", ...reactHandlers);
  }

  if (clientRoute.index || serverRoute.index) {
    const indexApp = (serverRoute.index?.default ?? new Hono()) as Hono<
      E,
      S,
      BasePath
    >;
    if (clientRoute.index) {
      indexApp.get("/", ...reactHandlers);
      indexApp.post("/", ...reactHandlers);
    }
    app.route("/", indexApp);
  }

  const allChildPaths = new Set([
    ...(serverRoute.children || []).map((r) => r.path),
    ...(clientRoute.children || []).map((r) => r.path),
  ]);

  for (const childPath of allChildPaths) {
    const serverChild = serverRoute.children?.find((r) => r.path === childPath);
    const clientChild = clientRoute.children?.find((r) => r.path === childPath);

    if (serverChild || clientChild) {
      const childApp = buildApp(
        serverChild || { path: childPath as BasePath },
        clientChild || { path: childPath },
        reactHandlers,
      );
      app.route(`/${childPath}`, childApp);
    }
  }

  if (projectRoot) {
    const cwd = Deno.cwd();
    let publicPath = path.resolve(projectRoot, "./public");
    const relativePath = path.relative(cwd, publicPath);

    publicPath = Deno.build.os === "windows"
      ? relativePath.replace(/\\/g, "/")
      : relativePath;

    if (args["hot-reload"]) {
      const devClientPath = path.fromFileUrl(
        import.meta.resolve("./dev-client.js"),
      );
      const devClientContent = Deno.readTextFileSync(devClientPath);
      app.get("/dev-client.js", (c) => {
        return c.body(devClientContent, 200, {
          "Content-Type": "application/javascript",
        });
      });
    }

    app.get(
      "*",
      serveStatic({
        root: publicPath,
      }),
    );
  }

  if (clientRoute.catchall || serverRoute.catchall) {
    const catchallApp = (serverRoute.catchall?.default ?? new Hono()) as Hono<
      E,
      S,
      BasePath
    >;
    if (clientRoute.catchall) {
      catchallApp.get("/", ...reactHandlers);
      catchallApp.post("/", ...reactHandlers);
    }
    app.route("/:*{.+}", catchallApp);
    app.route("*", catchallApp);
  }

  app.use("*", notFound);
  return app;
}
