import { AsyncLocalStorage } from "node:async_hooks";

import * as path from "@std/path";
import { parseArgs } from "@std/cli/parse-args";
import { HttpError } from "./mod.ts";
import { SpanStatusCode } from "@opentelemetry/api";
import { Hono } from "hono";
import type { Context, Env, Schema } from "hono";
import { createFactory } from "hono/factory";
import { serveStatic } from "hono/deno";
import { stream } from "hono/streaming";
import type { StatusCode } from "hono/utils/http-status";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import {
  createStaticHandler,
  createStaticRouter,
  StaticRouterProvider,
} from "react-router";
import type {
  DataRouteObject,
  RouterContextProvider,
  StaticHandlerContext,
} from "react-router";
import type { RouteObject } from "react-router";
import { StrictMode, Suspense, use } from "react";
import { renderToReadableStream } from "react-dom/server";
import { isbot } from "isbot";

import type { ClientRoute } from "./client.tsx";
import { getInstance } from "./utils/otel.ts";

import { App, generateRouteId, JuniperContextProvider } from "./_client.tsx";
import {
  cborEncode,
  containsPromises,
  createStreamingLoaderData,
  serializeAllContext,
  serializeError,
  serializeHydrationData,
  serializeLoaderData,
} from "./_serialization.ts";
import type { SerializedHydrationData } from "./_serialization.ts";
import { startActiveSpan } from "./utils/_otel.ts";
import type { ActionFunction, LoaderFunction } from "./mod.ts";
import { isHttpErrorLike } from "@udibo/http-error";

/**
 * Inlined dev-client.js content for hot reload functionality.
 * This is served directly to avoid file system or network access at runtime.
 */
const DEV_CLIENT_JS = `/**
 * Client-side script for connecting to the Juniper dev server.
 * This script establishes an SSE connection to the dev server and
 * automatically reloads the page when the server indicates a rebuild.
 */

/**
 * Connects to the dev server SSE endpoint and handles automatic reloads
 */
function connectToDevServer(devServerPort = 9001) {
  const devServerUrl = \`http://localhost:\${devServerPort}/sse\`;

  console.log("ðŸ”— Connecting to dev server at", devServerUrl);

  const eventSource = new EventSource(devServerUrl);

  eventSource.addEventListener("dev-connection", (_event) => {
    console.log("âœ… Connected to dev server");
  });

  eventSource.addEventListener("dev-reload", (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log("ðŸ”„ Dev server requested reload:", data);
      globalThis.location.reload();
    } catch (error) {
      console.error("âŒ Failed to parse reload message:", error);
    }
  });

  eventSource.addEventListener("dev-keepalive", (_event) => {
    console.debug("ðŸ’“ Dev server keepalive");
  });

  eventSource.onerror = (error) => {
    console.error("âŒ Dev server connection error:", error);
    setTimeout(() => {
      console.log("ðŸ”„ Attempting to reconnect to dev server...");
      connectToDevServer(devServerPort);
    }, 5000);
  };

  globalThis.addEventListener("beforeunload", () => {
    eventSource.close();
  });
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    connectToDevServer();
  });
} else {
  connectToDevServer();
}
`;

const args = parseArgs(Deno.args, {
  boolean: ["hot-reload"],
});

interface RouteContext {
  routeId: string;
  isClientRoute: boolean;
}

const routeContextStorage = new AsyncLocalStorage<RouteContext>();

export function getRouteContext(): RouteContext | undefined {
  return routeContextStorage.getStore();
}

/**
 * The default environment type for the Juniper application.
 */
export type AppEnv = Env & {
  Variables: {
    context: RouterContextProvider;
  };
};

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 * import { client } from "./main.tsx";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ],
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 */
interface ServerRouteModule {
  // deno-lint-ignore no-explicit-any -- Accepts any Hono app regardless of its type parameters
  default?: Hono<any, any, any>;
  loader?: LoaderFunction;
  action?: ActionFunction;
}

interface ServerMainRouteModule extends ServerRouteModule {
  publicEnvKeys?: string[];
}

export const DEFAULT_PUBLIC_ENV_KEYS = ["APP_NAME", "APP_ENV", "NODE_ENV"];

function getAllPublicEnvKeys<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>): string[] {
  return [
    ...new Set([
      ...DEFAULT_PUBLIC_ENV_KEYS,
      ...(route.main?.publicEnvKeys ?? []),
    ]),
  ];
}

export interface Route<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: ServerMainRouteModule;
  /** Optional index route handler (handles exact path matches) */
  index?: ServerRouteModule;
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: ServerRouteModule;
  /** Optional array of child routes */
  children?: Route<E, S, BasePath>[];
}

function HydrationScript(
  { serializedHydrationData }: { serializedHydrationData: Promise<string> },
) {
  const hydrateScript = use(serializedHydrationData);
  return (
    <script
      type="module"
      suppressHydrationWarning
      dangerouslySetInnerHTML={{ __html: hydrateScript }}
    />
  );
}

/**
 * Gathers public environment variables to share with the client.
 *
 * @param allPublicEnvKeys - All environment variable keys to include
 * @returns An object containing the public environment variables
 */
function getPublicEnv(allPublicEnvKeys: string[]): Record<string, string> {
  const publicEnv: Record<string, string> = {};
  for (const key of allPublicEnvKeys) {
    const value = Deno.env.get(key);
    if (value !== undefined) {
      publicEnv[key] = value;
    }
  }
  return publicEnv;
}

async function convertToHttpError(cause: unknown): Promise<HttpError> {
  if (
    cause !== null &&
    typeof cause === "object" &&
    !(cause instanceof HttpError) &&
    "getResponse" in cause &&
    typeof cause.getResponse === "function"
  ) {
    const response = cause.getResponse() as Response;
    const status = response.status;
    const headers = new Headers(response.headers);

    let message: string | undefined;
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("application/problem+json")) {
      return HttpError.from({
        status,
        ...await response.json(),
      });
    } else {
      message = await response.text();
    }

    const error = new HttpError(status, { message, headers });
    error.headers = headers;
    return error;
  }
  return HttpError.from(cause);
}

interface RenderOptions {
  allPublicEnvKeys: string[];
}

interface RenderDocumentOptions {
  context: StaticHandlerContext;
  requestContext: RouterContextProvider;
  dataRoutes: DataRouteObject[];
  renderOptions: RenderOptions;
  request: Request;
  waitForAllReady?: boolean;
  presetError?: HttpError;
}

async function renderDocument(
  c: Context<AppEnv>,
  options: RenderDocumentOptions,
): Promise<Response> {
  const {
    context,
    requestContext,
    dataRoutes,
    renderOptions,
    request,
    waitForAllReady,
    presetError,
  } = options;
  const { allPublicEnvKeys } = renderOptions;

  const router = createStaticRouter(dataRoutes, context);

  let renderStream: Awaited<ReturnType<typeof renderToReadableStream>>;
  let aborted = false;
  let renderAttempts = 0;

  async function render() {
    renderAttempts += 1;
    let retry = false;

    await startActiveSpan("render.attempt", async (renderAttemptSpan) => {
      renderAttemptSpan.setAttribute("render.attempt.index", renderAttempts);
      try {
        // Use CBOR-based serialization
        const hydrationData = {
          publicEnv: getPublicEnv(allPublicEnvKeys),
          serializedContext: serializeAllContext(requestContext),
          matches: context.matches.map((match) => ({
            id: match.route.id,
          })),
          errors: context.errors ?? undefined,
          loaderData: context.loaderData ?? undefined,
          actionData: context.actionData ?? undefined,
        };

        const serializedHydrationData = serializeHydrationData(
          hydrationData,
        ).then((data: SerializedHydrationData) =>
          `import { client } from "/build/main.js"; window.__juniperHydrationData = ${
            JSON.stringify(data)
          }; await client.hydrate();`
        );

        const bootstrapScripts: string[] = [];
        if (args["hot-reload"]) {
          bootstrapScripts.push("/dev-client.js");
        }

        renderStream = await renderToReadableStream(
          <StrictMode>
            <App>
              <JuniperContextProvider context={requestContext}>
                <StaticRouterProvider
                  router={router}
                  context={context}
                  hydrate={false}
                />
              </JuniperContextProvider>
              <Suspense fallback={null}>
                <HydrationScript
                  serializedHydrationData={serializedHydrationData}
                />
              </Suspense>
            </App>
          </StrictMode>,
          {
            bootstrapModules: ["/build/main.js"],
            bootstrapScripts,
            signal: request.signal,
            onError: (renderError: unknown) => {
              const abortError = renderError instanceof Error &&
                renderError.name === "AbortError";
              if (aborted && abortError) return;
              console.error("render onError", renderError);
              if (abortError) {
                aborted = true;
              }
            },
          },
        );

        if (waitForAllReady) {
          await renderStream.allReady;
        }
      } catch (error) {
        if (
          request.signal.aborted ||
          (error instanceof Error && error.name === "AbortError")
        ) {
          throw error;
        }
        if (!context.errors) context.errors = {};
        if (
          context._deepestRenderedBoundaryId &&
          !(context._deepestRenderedBoundaryId in context.errors)
        ) {
          context.errors[context._deepestRenderedBoundaryId] = error;
          retry = true;
        } else {
          throw error;
        }
      }
    });

    if (retry) {
      await render();
    }
  }

  await startActiveSpan("render", async (renderSpan) => {
    await render();
    renderSpan.setAttribute("render.attempt.count", renderAttempts);
  });

  const deepestMatch = context.matches[context.matches.length - 1];
  const actionHeaders = context.actionHeaders[deepestMatch.route.id];
  const loaderHeaders = context.loaderHeaders[deepestMatch.route.id];

  const statusCode = (presetError?.status ??
    Object.values(context.errors ?? {})
      .find((value: unknown) => isHttpErrorLike(value))
      ?.status ??
    context.statusCode ??
    200) as StatusCode;

  c.status(statusCode);

  for (const [key, value] of actionHeaders?.entries() ?? []) {
    c.header(key, value);
  }
  for (const [key, value] of loaderHeaders?.entries() ?? []) {
    c.header(key, value);
  }

  if (presetError?.headers) {
    for (const [key, value] of presetError.headers.entries()) {
      if (key.toLowerCase() !== "content-type") {
        c.header(key, value);
      }
    }
  }

  c.header("Content-Type", "text/html; charset=utf-8");
  c.header("Vary", "Accept");

  return stream(c, async (streamInstance) => {
    return await startActiveSpan("stream.pipe", async (streamSpan) => {
      try {
        await streamInstance.pipe(renderStream);
      } catch (cause) {
        if (typeof cause === "undefined" && request.signal.aborted) {
          streamSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message: "Stream aborted",
          });
        } else {
          throw cause;
        }
      }
    });
  });
}

async function createErrorContext(
  error: Error,
  dataRoutes: DataRouteObject[],
  request: Request,
  requestContext: RouterContextProvider,
): Promise<StaticHandlerContext | Response> {
  const { query } = createStaticHandler(dataRoutes as unknown as RouteObject[]);
  const contextOrResponse = await query(request, { requestContext });

  if (contextOrResponse instanceof Response) {
    return contextOrResponse;
  }

  const context = contextOrResponse;
  if (!context.errors) context.errors = {};

  let errorRouteId = "/";
  for (let i = context.matches.length - 1; i >= 0; i--) {
    const match = context.matches[i];
    const route = match.route;
    if (route.hasErrorBoundary) {
      errorRouteId = route.id ?? "/";
      break;
    }
  }
  context.errors[errorRouteId] = error;

  if (context.loaderData) {
    delete context.loaderData[errorRouteId];
  }

  return context;
}

type ErrorHandler = (
  cause: unknown,
  c: Context<AppEnv>,
) => Response | Promise<Response>;

function serverLoaderError() {
  throw new Error("Cannot call serverLoader from server");
}

function serverActionError() {
  throw new Error("Cannot call serverAction from server");
}

type LazyRouteFunction = () => Promise<
  Omit<RouteObject, "children" | "index" | "path">
>;

function wrapLazyWithServerFallback(
  lazy: RouteObject["lazy"],
  serverModule: Pick<ServerRouteModule, "loader" | "action"> | undefined,
): RouteObject["lazy"] {
  if (!lazy || typeof lazy !== "function") return lazy;

  const hasServerLoader = !!serverModule?.loader;
  const hasServerAction = !!serverModule?.action;

  const lazyFn = lazy as LazyRouteFunction;
  const wrappedLazy: LazyRouteFunction = async () => {
    const result = await lazyFn() as Record<string, unknown>;
    const { middleware: _middleware, ...rest } = result;

    // Strip client loader/action only if server has them
    if (hasServerLoader) delete rest.loader;
    if (hasServerAction) delete rest.action;

    return rest;
  };
  return wrappedLazy as RouteObject["lazy"];
}

/**
 * Merges server routes with client route objects. When a server loader/action exists,
 * it replaces the client version. When no server loader/action exists, the client
 * loader/action is preserved and will run on the server during SSR.
 *
 * @param serverRoute - The server route configuration
 * @param clientRoutes - The client route objects from React Router
 * @returns The merged route objects with server loaders/actions
 */
export function mergeServerRoutes<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoutes: RouteObject[],
): RouteObject[] {
  function applyServerModule(
    routeObj: RouteObject,
    serverModule: Pick<ServerRouteModule, "loader" | "action"> | undefined,
  ): void {
    // Save client handlers before potentially deleting them
    const clientLoader = routeObj.loader;
    const clientAction = routeObj.action;

    delete routeObj.loader;
    delete routeObj.action;
    delete routeObj.middleware;
    routeObj.lazy = wrapLazyWithServerFallback(routeObj.lazy, serverModule);

    if (serverModule?.loader) {
      const serverLoader = serverModule.loader;
      routeObj.loader = async (args: LoaderFunctionArgs) => {
        const { context, params, request } = args;
        return await serverLoader({
          context,
          params,
          request,
          serverLoader: serverLoaderError,
        });
      };
    } else if (clientLoader) {
      // Use client loader on server when no server loader exists
      routeObj.loader = clientLoader;
    }

    if (serverModule?.action) {
      const serverAction = serverModule.action;
      routeObj.action = async (args: ActionFunctionArgs) => {
        const { context, params, request } = args;
        return await serverAction({
          context,
          params,
          request,
          serverAction: serverActionError,
        });
      };
    } else if (clientAction) {
      // Use client action on server when no server action exists
      routeObj.action = clientAction;
    }
  }

  function processRouteObjects(
    serverRouteNode: Route<E, S, BasePath> | undefined,
    clientObjs: RouteObject[],
  ): RouteObject[] {
    return clientObjs.map((clientObj) => {
      const newRouteObj: RouteObject = { ...clientObj };

      if (clientObj.index) {
        applyServerModule(newRouteObj, serverRouteNode?.index);
      } else if (clientObj.path === "*") {
        applyServerModule(newRouteObj, serverRouteNode?.catchall);
      } else {
        applyServerModule(newRouteObj, serverRouteNode?.main);
      }

      if (clientObj.children && clientObj.children.length > 0) {
        const childServerRoutes = serverRouteNode?.children ?? [];
        newRouteObj.children = clientObj.children.map((childClientObj) => {
          const matchingServerChild = childServerRoutes.find((sr) => {
            if (childClientObj.index) {
              return sr.path === clientObj.path && sr.index !== undefined;
            }
            if (childClientObj.path === "*") {
              return sr.path === "*" || sr.catchall !== undefined;
            }
            return sr.path === childClientObj.path;
          });

          if (childClientObj.index) {
            const serverIndex = matchingServerChild?.index ??
              serverRouteNode?.index;
            const indexRoute: RouteObject = { ...childClientObj };
            applyServerModule(indexRoute, serverIndex);
            return indexRoute;
          } else if (childClientObj.path === "*") {
            const serverCatchall = matchingServerChild?.catchall ??
              serverRouteNode?.catchall;
            const catchallRoute: RouteObject = { ...childClientObj };
            applyServerModule(catchallRoute, serverCatchall);
            return catchallRoute;
          }

          if (matchingServerChild) {
            return processRouteObjects(matchingServerChild, [
              childClientObj,
            ])[0];
          }

          const noServerRoute: RouteObject = { ...childClientObj };
          applyServerModule(noServerRoute, undefined);
          if (childClientObj.children) {
            noServerRoute.children = processRouteObjects(
              undefined,
              childClientObj.children,
            );
          }
          return noServerRoute;
        });
      }

      return newRouteObj;
    });
  }

  return processRouteObjects(serverRoute, clientRoutes);
}

type ReactHandlers = ReturnType<
  ReturnType<typeof createFactory<AppEnv>>["createHandlers"]
>;

interface HandlersResult {
  handlers: ReactHandlers;
  errorHandler: ErrorHandler;
}

/**
 * Creates handlers for React Router.
 *
 * This function is used to create handlers for React Router.
 *
 * @param route - The route configuration
 * @param routes - The routes to create handlers for
 * @returns An object containing handlers and errorHandler for client route error rendering
 */
export function createHandlers<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>, routes: RouteObject[]): HandlersResult {
  const factory = createFactory<AppEnv>();
  const allPublicEnvKeys = getAllPublicEnvKeys(route);
  const { query, dataRoutes, queryRoute } = createStaticHandler(routes);

  const renderOptions: RenderOptions = {
    allPublicEnvKeys,
  };

  const handlers = factory.createHandlers(
    async function handleDocumentRequest(c, next) {
      return await startActiveSpan("handleDocumentRequest", async (_span) => {
        if (c.req.header("X-Juniper-Route-Id")) {
          return next();
        }

        const requestContext = c.get("context");
        const contextOrResponse = await startActiveSpan(
          "query",
          async (_querySpan) => {
            return await query(c.req.raw, { requestContext });
          },
        );

        if (contextOrResponse instanceof Response) {
          return contextOrResponse;
        }

        Object.entries(contextOrResponse.errors ?? {}).forEach(
          ([key, value]) => {
            console.error(`Loader ${key} error:`, value);
          },
        );
        return renderDocument(c, {
          context: contextOrResponse,
          requestContext,
          dataRoutes,
          renderOptions,
          request: c.req.raw,
          waitForAllReady: isbot(c.req.header("user-agent")),
        });
      });
    },
    async function handleDataRequest(c) {
      return await startActiveSpan("handleDataRequest", async (_span) => {
        const routeId = c.req.header("X-Juniper-Route-Id");

        const requestContext = c.get("context");
        const dataOrResponse = await queryRoute(c.req.raw, {
          requestContext,
          routeId,
        });

        c.header("Vary", "Accept");
        if (dataOrResponse instanceof Response) {
          const location = dataOrResponse.headers.get("Location");
          if (
            dataOrResponse.status >= 300 && dataOrResponse.status < 400 &&
            location
          ) {
            c.header("X-Juniper", "redirect");
            return c.json({ location });
          }
          return dataOrResponse;
        }

        // Check if data contains promises - if so, use streaming
        if (containsPromises(dataOrResponse)) {
          c.header("Content-Type", "application/cbor-stream");

          const dataStream = createStreamingLoaderData(dataOrResponse);
          return stream(c, async (streamInstance) => {
            await streamInstance.pipe(dataStream);
          });
        }

        // No promises - use non-streaming response for better performance
        const cborData = await serializeLoaderData(dataOrResponse);
        return new Response(cborData as unknown as BodyInit, {
          headers: {
            "Content-Type": "application/cbor",
            "Vary": "Accept",
          },
        });
      });
    },
  );

  const errorHandler: ErrorHandler = async (cause, c) => {
    const error = await convertToHttpError(cause);
    if (!error.instance) {
      const instance = getInstance();
      if (instance) {
        error.instance = instance;
      }
    }
    console.error(error);

    if (c.req.header("X-Juniper-Route-Id")) {
      // Use registry-based error serialization
      const serialized = serializeError(error);
      const cborData = cborEncode(serialized);
      const headers = new Headers({
        "Content-Type": "application/cbor",
        "Vary": "Accept",
      });
      if (error.headers) {
        for (const [key, value] of error.headers.entries()) {
          if (key.toLowerCase() !== "content-type") {
            headers.set(key, value);
          }
        }
      }
      return new Response(cborData as unknown as BodyInit, {
        status: error.status,
        headers,
      });
    }

    // For 404s on paths with file extensions, return simple response
    // to avoid wasting resources rendering pages for bot requests
    if (error.status === 404) {
      const url = new URL(c.req.url);
      const lastSegment = url.pathname.split("/").pop() ?? "";
      if (lastSegment.includes(".")) {
        return error.getResponse();
      }
    }

    try {
      const requestContext = c.get("context");
      const contextOrResponse = await createErrorContext(
        error,
        dataRoutes,
        c.req.raw,
        requestContext,
      );

      if (contextOrResponse instanceof Response) {
        return contextOrResponse;
      }

      return renderDocument(c, {
        context: contextOrResponse,
        requestContext,
        dataRoutes,
        renderOptions,
        request: c.req.raw,
        waitForAllReady: true,
        presetError: error,
      });
    } catch (renderError) {
      console.error(
        "Failed to render error page, falling back to JSON:",
        renderError,
      );
      return error.getResponse();
    }
  };

  return { handlers: handlers as unknown as ReactHandlers, errorHandler };
}

/**
 * Builds a Hono application by combining client and server routes.
 *
 * The logic is:
 * - If only server routes exist: use them as-is
 * - If only client routes exist: add React handlers for document requests
 * - If both exist: server routes run first (middleware), then client handlers for document requests
 *
 * @param serverRoute - The server route configuration
 * @param clientRoute - The client route configuration
 * @param reactHandlers - The React Router handlers for rendering pages
 * @param projectRoot - Optional project root for static file serving
 * @param parentPath - The parent path for generating route IDs
 * @param errorHandler - Error handler for client routes that renders errors via React Router
 * @returns A configured Hono application
 */
export function buildApp<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoute: ClientRoute,
  reactHandlers: ReactHandlers,
  projectRoot?: string,
  parentPath: string = "/",
  errorHandler?: ErrorHandler,
): Hono<E, S, BasePath> {
  const notFound = createFactory().createMiddleware(() => {
    throw new HttpError(404, "Not found");
  });

  const isClientRoute = !!(
    clientRoute.main || clientRoute.index || clientRoute.catchall
  );

  function createClientRouteApp(
    serverMiddleware: Hono<E, S, BasePath> | undefined,
    currentRouteId: string,
    addHandlers: boolean,
  ): Hono<E, S, BasePath> {
    const routeApp = new Hono<E, S, BasePath>({ strict: true });

    if (errorHandler) {
      routeApp.onError(
        errorHandler as unknown as Parameters<typeof routeApp.onError>[0],
      );
    }

    routeApp.use(async (_c, next) => {
      await routeContextStorage.run(
        { routeId: currentRouteId, isClientRoute: true },
        async () => {
          await next();
        },
      );
    });

    if (serverMiddleware) {
      routeApp.route("/", serverMiddleware);
    }

    if (addHandlers) {
      routeApp.get("/", ...reactHandlers);
      routeApp.post("/", ...reactHandlers);
    }

    return routeApp;
  }

  function wrapServerOnlyApp(
    serverApp: Hono<E, S, BasePath>,
  ): Hono<E, S, BasePath> {
    const wrapper = new Hono<E, S, BasePath>({ strict: true });
    wrapper.onError(async (cause) => {
      const error = await convertToHttpError(cause);
      if (!error.instance) {
        const instance = getInstance();
        if (instance) {
          error.instance = instance;
        }
      }
      console.error(error);
      return error.getResponse();
    });
    wrapper.route("/", serverApp);
    return wrapper;
  }

  const routeId = parentPath;
  let app: Hono<E, S, BasePath>;

  if (isClientRoute && errorHandler) {
    const serverMiddleware = serverRoute.main?.default as
      | Hono<E, S, BasePath>
      | undefined;
    const addHandlers = !clientRoute.index && !!clientRoute.main;
    app = createClientRouteApp(serverMiddleware, routeId, addHandlers);
  } else if (serverRoute.main?.default) {
    app = wrapServerOnlyApp(serverRoute.main.default as Hono<E, S, BasePath>);
  } else {
    app = new Hono<E, S, BasePath>();
  }

  if (clientRoute.index || serverRoute.index) {
    const indexRouteId = generateRouteId(parentPath, "", "index");
    let indexApp: Hono<E, S, BasePath>;
    if (clientRoute.index && errorHandler) {
      const serverMiddleware = serverRoute.index?.default as
        | Hono<E, S, BasePath>
        | undefined;
      indexApp = createClientRouteApp(serverMiddleware, indexRouteId, true);
    } else if (serverRoute.index?.default) {
      indexApp = wrapServerOnlyApp(
        serverRoute.index.default as Hono<E, S, BasePath>,
      );
    } else {
      indexApp = new Hono<E, S, BasePath>();
    }
    app.route("/", indexApp);
  }

  const allChildPaths = new Set([
    ...(serverRoute.children || []).map((r) => r.path),
    ...(clientRoute.children || []).map((r) => r.path),
  ]);

  for (const childPath of allChildPaths) {
    const serverChild = serverRoute.children?.find((r) => r.path === childPath);
    const clientChild = clientRoute.children?.find((r) => r.path === childPath);

    if (serverChild || clientChild) {
      const childParentPath = generateRouteId(parentPath, childPath, "main");
      const childApp = buildApp(
        serverChild || { path: childPath as BasePath },
        clientChild || { path: childPath },
        reactHandlers,
        undefined,
        childParentPath,
        errorHandler,
      );
      app.route(`/${childPath}`, childApp);
    }
  }

  if (projectRoot) {
    const cwd = Deno.cwd();
    let publicPath = path.resolve(projectRoot, "./public");
    const relativePath = path.relative(cwd, publicPath);

    publicPath = Deno.build.os === "windows"
      ? relativePath.replace(/\\/g, "/")
      : relativePath;

    if (args["hot-reload"]) {
      app.get("/dev-client.js", (c) => {
        return c.body(DEV_CLIENT_JS, 200, {
          "Content-Type": "application/javascript",
        });
      });
    }

    app.get(
      "*",
      serveStatic({
        root: publicPath,
      }),
    );
  }

  if (clientRoute.catchall || serverRoute.catchall) {
    const catchallRouteId = generateRouteId(parentPath, "", "catchall");
    let catchallApp: Hono<E, S, BasePath>;
    if (clientRoute.catchall && errorHandler) {
      const serverMiddleware = serverRoute.catchall?.default as
        | Hono<E, S, BasePath>
        | undefined;
      catchallApp = createClientRouteApp(
        serverMiddleware,
        catchallRouteId,
        true,
      );
    } else if (serverRoute.catchall?.default) {
      catchallApp = wrapServerOnlyApp(
        serverRoute.catchall.default as Hono<E, S, BasePath>,
      );
    } else {
      catchallApp = new Hono<E, S, BasePath>();
    }
    app.route("/:*{.+}", catchallApp);
    app.route("*", catchallApp);
  }

  app.use("*", notFound);
  return app;
}
