import { AsyncLocalStorage } from "node:async_hooks";

import * as path from "@std/path";
import { parseArgs } from "@std/cli/parse-args";
import { HttpError } from "@udibo/juniper";
import { SpanStatusCode } from "@opentelemetry/api";
import { Hono } from "hono";
import type { Context, Env, Schema } from "hono";
import { createFactory } from "hono/factory";
import { serveStatic } from "hono/deno";
import { stream } from "hono/streaming";
import type { StatusCode } from "hono/utils/http-status";
import type {
  ActionFunctionArgs,
  HydrationState,
  LoaderFunctionArgs,
} from "react-router";
import {
  createStaticHandler,
  createStaticRouter,
  StaticRouterProvider,
} from "react-router";
import type {
  DataRouteObject,
  RouterContextProvider,
  StaticHandlerContext,
} from "react-router";
import type { RouteObject } from "react-router";
import { StrictMode, Suspense, use } from "react";
import { renderToReadableStream } from "react-dom/server";
import serialize from "serialize-javascript";
import SuperJSON from "superjson";
import { isbot } from "isbot";

import type {
  ClientRoute,
  HydrationData,
  SerializedError,
} from "@udibo/juniper/client";
import { isDevelopment } from "@udibo/juniper/utils/env";
import { getInstance } from "@udibo/juniper/utils/otel";

import {
  App,
  generateRouteId,
  JuniperContextProvider,
  type SerializedHydrationData,
  type SerializedHydrationDataPromises,
} from "./_client.tsx";
import { startActiveSpan } from "./utils/_otel.ts";
import type { ActionFunction, LoaderFunction } from "@udibo/juniper";

const args = parseArgs(Deno.args, {
  boolean: ["hot-reload"],
});

interface RouteContext {
  routeId: string;
  isClientRoute: boolean;
}

const routeContextStorage = new AsyncLocalStorage<RouteContext>();

export function getRouteContext(): RouteContext | undefined {
  return routeContextStorage.getStore();
}

/**
 * The default environment type for the Juniper application.
 */
export type AppEnv = Env & {
  Variables: {
    context: RouterContextProvider;
  };
};

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 * import { client } from "./main.tsx";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ],
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 */
interface ServerRouteModule {
  // deno-lint-ignore no-explicit-any -- Accepts any Hono app regardless of its type parameters
  default?: Hono<any, any, any>;
  loader?: LoaderFunction;
  action?: ActionFunction;
}

interface ServerMainRouteModule extends ServerRouteModule {
  serializeError?: (error: unknown) => SerializedError | unknown;
  publicEnvKeys?: string[];
}

export const DEFAULT_PUBLIC_ENV_KEYS = ["APP_NAME", "APP_ENV", "NODE_ENV"];

type SerializeErrorFn = (error: unknown) => SerializedError | unknown;

function getSerializeError<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>): SerializeErrorFn {
  return route.main?.serializeError ?? (() => {});
}

function getAllPublicEnvKeys<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>): string[] {
  return [
    ...new Set([
      ...DEFAULT_PUBLIC_ENV_KEYS,
      ...(route.main?.publicEnvKeys ?? []),
    ]),
  ];
}

export interface Route<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: ServerMainRouteModule;
  /** Optional index route handler (handles exact path matches) */
  index?: ServerRouteModule;
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: ServerRouteModule;
  /** Optional array of child routes */
  children?: Route<E, S, BasePath>[];
}

/**
 * Serializes an error to a serialized error.
 * The default serialize error function supports HttpError, Error, and global Error subclasses like TypeError.
 *
 * @param error - The error to serialize.
 * @returns The serialized error.
 */
export function serializeErrorDefault(
  error: unknown,
): SerializedError | unknown {
  let serializedError: SerializedError | unknown = error;
  if (error instanceof Error) {
    if (error instanceof HttpError) {
      if (!error.instance) error.instance = getInstance();
      serializedError = {
        __type: "Error",
        __subType: "HttpError",
        ...error.toJSON(),
      };
    } else {
      serializedError = { __type: "Error" };
      if (error.name !== "Error") {
        (serializedError as SerializedError).__subType = error.name;
      }
      (serializedError as SerializedError).message = error.message;
    }
    if (isDevelopment()) {
      (serializedError as SerializedError).stack = error.stack;
    }
  }
  return serializedError;
}

/**
 * Processes a single route data object or array, resolving any Promises and tracking
 * which keys were resolved or rejected for later reconstruction.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
async function processRouteData(
  routeData: Record<string, unknown> | unknown[],
  serializeError?: (error: unknown) => unknown,
): Promise<{
  resolvedData: Record<string, unknown> | unknown[];
  resolvedKeys: string[];
  rejectedKeys: string[];
}> {
  const resolvedKeys: string[] = [];
  const rejectedKeys: string[] = [];
  let resolvedData: Record<string, unknown> | unknown[];

  if (Array.isArray(routeData)) {
    resolvedData = [];

    for (let i = 0; i < routeData.length; i++) {
      const value = routeData[i];
      if (value instanceof Promise) {
        try {
          const resolvedValue = await Promise.resolve(value);
          resolvedData[i] = resolvedValue;
          resolvedKeys.push(String(i));
        } catch (error) {
          resolvedData[i] = serializeError?.(error) ??
            serializeErrorDefault(error);
          rejectedKeys.push(String(i));
        }
      } else {
        resolvedData[i] = value;
      }
    }
  } else {
    resolvedData = {};

    for (const [key, value] of Object.entries(routeData)) {
      if (value instanceof Promise) {
        try {
          const resolvedValue = await Promise.resolve(value);
          resolvedData[key] = resolvedValue;
          resolvedKeys.push(key);
        } catch (error) {
          resolvedData[key] = serializeError?.(error) ??
            serializeErrorDefault(error);
          rejectedKeys.push(key);
        }
      } else {
        resolvedData[key] = value;
      }
    }
  }

  return { resolvedData, resolvedKeys, rejectedKeys };
}

/**
 * Serializes hydration data by resolving all Promises and tracking their states.
 * Returns both the serialized data and metadata about which promises were resolved/rejected.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
export async function serializeHydrationData(
  hydrationData: HydrationData,
  options: {
    serializeError?: (error: unknown) => unknown;
  } = {},
): Promise<SerializedHydrationData> {
  const { serializeError } = options;
  const resolved: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };
  const rejected: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };

  const { publicEnv, matches } = hydrationData;

  // Serialize errors
  let errors: HydrationState["errors"];
  if (hydrationData.errors) {
    errors = {};
    for (const [key, serializedError] of Object.entries(hydrationData.errors)) {
      errors[key] = serializeError?.(serializedError) ??
        serializeErrorDefault(serializedError);
    }
  }

  // Process loader data
  let loaderData: HydrationState["loaderData"];
  if (hydrationData.loaderData) {
    loaderData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.loaderData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      loaderData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.loaderData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.loaderData![routeId] = rejectedKeys;
      }
    }
  }

  // Process action data
  let actionData: HydrationState["actionData"];
  if (hydrationData.actionData) {
    actionData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.actionData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      actionData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.actionData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.actionData![routeId] = rejectedKeys;
      }
    }
  }

  const { json, meta } = SuperJSON.serialize({
    matches,
    errors,
    loaderData,
    actionData,
  });

  return {
    json,
    meta,
    publicEnv,
    resolved,
    rejected,
  };
}

function HydrationScript(
  { serializedHydrationData }: { serializedHydrationData: Promise<string> },
) {
  const hydrateScript = use(serializedHydrationData);
  return (
    <script
      type="module"
      suppressHydrationWarning
      dangerouslySetInnerHTML={{ __html: hydrateScript }}
    />
  );
}

/**
 * Gathers public environment variables to share with the client.
 *
 * @param allPublicEnvKeys - All environment variable keys to include
 * @returns An object containing the public environment variables
 */
function getPublicEnv(allPublicEnvKeys: string[]): Record<string, string> {
  const publicEnv: Record<string, string> = {};
  for (const key of allPublicEnvKeys) {
    const value = Deno.env.get(key);
    if (value !== undefined) {
      publicEnv[key] = value;
    }
  }
  return publicEnv;
}

async function convertToHttpError(cause: unknown): Promise<HttpError> {
  if (
    cause !== null &&
    typeof cause === "object" &&
    !(cause instanceof HttpError) &&
    "getResponse" in cause &&
    typeof cause.getResponse === "function"
  ) {
    const response = cause.getResponse() as Response;
    const status = response.status;
    const headers = new Headers(response.headers);

    let message: string | undefined;
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("application/problem+json")) {
      return HttpError.from({
        status,
        ...await response.json(),
      });
    } else {
      message = await response.text();
    }

    const error = new HttpError(status, { message, headers });
    error.headers = headers;
    return error;
  }
  return HttpError.from(cause);
}

interface RenderOptions {
  serializeError: SerializeErrorFn;
  allPublicEnvKeys: string[];
}

interface RenderDocumentOptions {
  context: StaticHandlerContext;
  requestContext: RouterContextProvider;
  dataRoutes: DataRouteObject[];
  renderOptions: RenderOptions;
  request: Request;
  waitForAllReady?: boolean;
  presetError?: HttpError;
}

async function renderDocument(
  c: Context<AppEnv>,
  options: RenderDocumentOptions,
): Promise<Response> {
  const {
    context,
    requestContext,
    dataRoutes,
    renderOptions,
    request,
    waitForAllReady,
    presetError,
  } = options;
  const { serializeError, allPublicEnvKeys } = renderOptions;

  const router = createStaticRouter(dataRoutes, context);

  let renderStream: Awaited<ReturnType<typeof renderToReadableStream>>;
  let aborted = false;
  let renderAttempts = 0;

  async function render() {
    renderAttempts += 1;
    let retry = false;

    await startActiveSpan("render.attempt", async (renderAttemptSpan) => {
      renderAttemptSpan.setAttribute("render.attempt.index", renderAttempts);
      try {
        const hydrationData = {
          publicEnv: getPublicEnv(allPublicEnvKeys),
          matches: context.matches.map((match) => ({
            id: match.route.id,
          })),
          errors: context.errors,
          loaderData: context.loaderData,
          actionData: context.actionData,
        };

        const serializedHydrationData = serializeHydrationData(
          hydrationData,
          { serializeError },
        ).then((data) =>
          `import { client } from "/build/main.js"; window.__juniperHydrationData = ${
            serialize(data, { isJSON: true })
          }; await client.hydrate();`
        );

        const bootstrapScripts: string[] = [];
        if (args["hot-reload"]) {
          bootstrapScripts.push("/dev-client.js");
        }

        renderStream = await renderToReadableStream(
          <StrictMode>
            <App>
              <JuniperContextProvider context={requestContext}>
                <StaticRouterProvider
                  router={router}
                  context={context}
                  hydrate={false}
                />
              </JuniperContextProvider>
              <Suspense fallback={null}>
                <HydrationScript
                  serializedHydrationData={serializedHydrationData}
                />
              </Suspense>
            </App>
          </StrictMode>,
          {
            bootstrapModules: ["/build/main.js"],
            bootstrapScripts,
            signal: request.signal,
            onError: (renderError: unknown) => {
              const abortError = renderError instanceof Error &&
                renderError.name === "AbortError";
              if (aborted && abortError) return;
              console.error("render onError", renderError);
              if (abortError) {
                aborted = true;
              }
            },
          },
        );

        if (waitForAllReady) {
          await renderStream.allReady;
        }
      } catch (error) {
        if (
          request.signal.aborted ||
          (error instanceof Error && error.name === "AbortError")
        ) {
          throw error;
        }
        if (!context.errors) context.errors = {};
        if (
          context._deepestRenderedBoundaryId &&
          !(context._deepestRenderedBoundaryId in context.errors)
        ) {
          context.errors[context._deepestRenderedBoundaryId] = error;
          retry = true;
        } else {
          throw error;
        }
      }
    });

    if (retry) {
      await render();
    }
  }

  await startActiveSpan("render", async (renderSpan) => {
    await render();
    renderSpan.setAttribute("render.attempt.count", renderAttempts);
  });

  const deepestMatch = context.matches[context.matches.length - 1];
  const actionHeaders = context.actionHeaders[deepestMatch.route.id];
  const loaderHeaders = context.loaderHeaders[deepestMatch.route.id];

  const statusCode: StatusCode = presetError?.status ??
    Object.values(context.errors ?? {})
      .find((value: unknown) =>
        value instanceof Error && (value as HttpError).status
      )
      ?.status ??
    context.statusCode ??
    200;

  c.status(statusCode);

  for (const [key, value] of actionHeaders?.entries() ?? []) {
    c.header(key, value);
  }
  for (const [key, value] of loaderHeaders?.entries() ?? []) {
    c.header(key, value);
  }

  if (presetError?.headers) {
    for (const [key, value] of presetError.headers.entries()) {
      if (key.toLowerCase() !== "content-type") {
        c.header(key, value);
      }
    }
  }

  c.header("Content-Type", "text/html; charset=utf-8");
  c.header("Vary", "Accept");

  return stream(c, async (streamInstance) => {
    return await startActiveSpan("stream.pipe", async (streamSpan) => {
      try {
        await streamInstance.pipe(renderStream);
      } catch (cause) {
        if (typeof cause === "undefined" && request.signal.aborted) {
          streamSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message: "Stream aborted",
          });
        } else {
          throw cause;
        }
      }
    });
  });
}

async function createErrorContext(
  error: Error,
  dataRoutes: DataRouteObject[],
  request: Request,
  requestContext: RouterContextProvider,
): Promise<StaticHandlerContext | Response> {
  const { query } = createStaticHandler(dataRoutes as unknown as RouteObject[]);
  const contextOrResponse = await query(request, { requestContext });

  if (contextOrResponse instanceof Response) {
    return contextOrResponse;
  }

  const context = contextOrResponse;
  if (!context.errors) context.errors = {};

  let errorRouteId = "/";
  for (let i = context.matches.length - 1; i >= 0; i--) {
    const match = context.matches[i];
    const route = match.route;
    if (route.hasErrorBoundary) {
      errorRouteId = route.id ?? "/";
      break;
    }
  }
  context.errors[errorRouteId] = error;

  if (context.loaderData) {
    delete context.loaderData[errorRouteId];
  }

  return context;
}

type ErrorHandler = (
  cause: unknown,
  c: Context<AppEnv>,
) => Response | Promise<Response>;

function serverLoaderError() {
  throw new Error("Cannot call serverLoader from server");
}

function serverActionError() {
  throw new Error("Cannot call serverAction from server");
}

type LazyRouteFunction = () => Promise<
  Omit<RouteObject, "children" | "index" | "path">
>;

function wrapLazyToStripClientRouteHandlers(
  lazy: RouteObject["lazy"],
): RouteObject["lazy"] {
  if (!lazy || typeof lazy !== "function") return lazy;

  const lazyFn = lazy as LazyRouteFunction;
  const wrappedLazy: LazyRouteFunction = async () => {
    const {
      loader: _loader,
      action: _action,
      middleware: _middleware,
      ...rest
    } = await lazyFn() as Record<string, unknown>;
    return rest;
  };
  return wrappedLazy as RouteObject["lazy"];
}

/**
 * Merges server routes with client route objects, replacing client loaders/actions
 * with server-side implementations where available. Client loaders/actions are always
 * stripped from the route objects since they are only used for client-side navigation.
 *
 * @param serverRoute - The server route configuration
 * @param clientRoutes - The client route objects from React Router
 * @returns The merged route objects with server loaders/actions
 */
export function mergeServerRoutes<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoutes: RouteObject[],
): RouteObject[] {
  function applyServerModule(
    routeObj: RouteObject,
    serverModule: Pick<ServerRouteModule, "loader" | "action"> | undefined,
  ): void {
    delete routeObj.loader;
    delete routeObj.action;
    delete routeObj.middleware;
    routeObj.lazy = wrapLazyToStripClientRouteHandlers(routeObj.lazy);

    if (serverModule?.loader) {
      const serverLoader = serverModule.loader;
      routeObj.loader = async (args: LoaderFunctionArgs) => {
        const { context, params, request } = args;
        return await serverLoader({
          context,
          params,
          request,
          serverLoader: serverLoaderError,
        });
      };
    }
    if (serverModule?.action) {
      const serverAction = serverModule.action;
      routeObj.action = async (args: ActionFunctionArgs) => {
        const { context, params, request } = args;
        return await serverAction({
          context,
          params,
          request,
          serverAction: serverActionError,
        });
      };
    }
  }

  function processRouteObjects(
    serverRouteNode: Route<E, S, BasePath> | undefined,
    clientObjs: RouteObject[],
  ): RouteObject[] {
    return clientObjs.map((clientObj) => {
      const newRouteObj: RouteObject = { ...clientObj };

      if (clientObj.index) {
        applyServerModule(newRouteObj, serverRouteNode?.index);
      } else if (clientObj.path === "*") {
        applyServerModule(newRouteObj, serverRouteNode?.catchall);
      } else {
        applyServerModule(newRouteObj, serverRouteNode?.main);
      }

      if (clientObj.children && clientObj.children.length > 0) {
        const childServerRoutes = serverRouteNode?.children ?? [];
        newRouteObj.children = clientObj.children.map((childClientObj) => {
          const matchingServerChild = childServerRoutes.find((sr) => {
            if (childClientObj.index) {
              return sr.path === clientObj.path && sr.index !== undefined;
            }
            if (childClientObj.path === "*") {
              return sr.path === "*" || sr.catchall !== undefined;
            }
            return sr.path === childClientObj.path;
          });

          if (childClientObj.index) {
            const serverIndex = matchingServerChild?.index ??
              serverRouteNode?.index;
            const indexRoute: RouteObject = { ...childClientObj };
            applyServerModule(indexRoute, serverIndex);
            return indexRoute;
          } else if (childClientObj.path === "*") {
            const serverCatchall = matchingServerChild?.catchall ??
              serverRouteNode?.catchall;
            const catchallRoute: RouteObject = { ...childClientObj };
            applyServerModule(catchallRoute, serverCatchall);
            return catchallRoute;
          }

          if (matchingServerChild) {
            return processRouteObjects(matchingServerChild, [
              childClientObj,
            ])[0];
          }

          const noServerRoute: RouteObject = { ...childClientObj };
          applyServerModule(noServerRoute, undefined);
          if (childClientObj.children) {
            noServerRoute.children = processRouteObjects(
              undefined,
              childClientObj.children,
            );
          }
          return noServerRoute;
        });
      }

      return newRouteObj;
    });
  }

  return processRouteObjects(serverRoute, clientRoutes);
}

type ReactHandlers = ReturnType<
  ReturnType<typeof createFactory<AppEnv>>["createHandlers"]
>;

interface HandlersResult {
  handlers: ReactHandlers;
  errorHandler: ErrorHandler;
}

/**
 * Creates handlers for React Router.
 *
 * This function is used to create handlers for React Router.
 *
 * @param route - The route configuration
 * @param routes - The routes to create handlers for
 * @returns An object containing handlers and errorHandler for client route error rendering
 */
export function createHandlers<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(route: Route<E, S, BasePath>, routes: RouteObject[]): HandlersResult {
  const factory = createFactory<AppEnv>();
  const serializeError = getSerializeError(route);
  const allPublicEnvKeys = getAllPublicEnvKeys(route);
  const { query, dataRoutes, queryRoute } = createStaticHandler(routes);

  const renderOptions: RenderOptions = {
    serializeError,
    allPublicEnvKeys,
  };

  const handlers = factory.createHandlers(
    async function handleDocumentRequest(c, next) {
      return await startActiveSpan("handleDocumentRequest", async (_span) => {
        if (c.req.header("X-Juniper-Route-Id")) {
          return next();
        }

        const requestContext = c.get("context");
        const contextOrResponse = await startActiveSpan(
          "query",
          async (_querySpan) => {
            return await query(c.req.raw, { requestContext });
          },
        );

        if (contextOrResponse instanceof Response) {
          return contextOrResponse;
        }

        Object.entries(contextOrResponse.errors ?? {}).forEach(
          ([key, value]) => {
            console.error(`Loader ${key} error:`, value);
          },
        );
        return renderDocument(c, {
          context: contextOrResponse,
          requestContext,
          dataRoutes,
          renderOptions,
          request: c.req.raw,
          waitForAllReady: isbot(c.req.header("user-agent")),
        });
      });
    },
    async function handleDataRequest(c) {
      return await startActiveSpan("handleDataRequest", async (_span) => {
        const routeId = c.req.header("X-Juniper-Route-Id");

        const requestContext = c.get("context");
        const dataOrResponse = await queryRoute(c.req.raw, {
          requestContext,
          routeId,
        });

        c.header("Vary", "Accept");
        if (dataOrResponse instanceof Response) {
          const location = dataOrResponse.headers.get("Location");
          if (
            dataOrResponse.status >= 300 && dataOrResponse.status < 400 &&
            location
          ) {
            c.header("X-Juniper", "redirect");
            return c.json({ location });
          }
          return dataOrResponse;
        }

        c.header("X-Juniper", "serialized");
        return c.json(SuperJSON.serialize(dataOrResponse));
      });
    },
  );

  const errorHandler: ErrorHandler = async (cause, c) => {
    const error = await convertToHttpError(cause);
    if (!error.instance) {
      const instance = getInstance();
      if (instance) {
        error.instance = instance;
      }
    }
    console.error(error);

    if (c.req.header("X-Juniper-Route-Id")) {
      c.status(error.status as StatusCode);
      c.header("Vary", "Accept");
      c.header("X-Juniper", "serialized");
      if (error.headers) {
        for (const [key, value] of error.headers.entries()) {
          if (key.toLowerCase() !== "content-type") {
            c.header(key, value);
          }
        }
      }
      const serialized = serializeError(error) ?? serializeErrorDefault(error);
      return c.json(SuperJSON.serialize(serialized));
    }

    try {
      const requestContext = c.get("context");
      const contextOrResponse = await createErrorContext(
        error,
        dataRoutes,
        c.req.raw,
        requestContext,
      );

      if (contextOrResponse instanceof Response) {
        return contextOrResponse;
      }

      return renderDocument(c, {
        context: contextOrResponse,
        requestContext,
        dataRoutes,
        renderOptions,
        request: c.req.raw,
        waitForAllReady: true,
        presetError: error,
      });
    } catch (renderError) {
      console.error(
        "Failed to render error page, falling back to JSON:",
        renderError,
      );
      return error.getResponse();
    }
  };

  return { handlers: handlers as unknown as ReactHandlers, errorHandler };
}

/**
 * Builds a Hono application by combining client and server routes.
 *
 * The logic is:
 * - If only server routes exist: use them as-is
 * - If only client routes exist: add React handlers for document requests
 * - If both exist: server routes run first (middleware), then client handlers for document requests
 *
 * @param serverRoute - The server route configuration
 * @param clientRoute - The client route configuration
 * @param reactHandlers - The React Router handlers for rendering pages
 * @param projectRoot - Optional project root for static file serving
 * @param parentPath - The parent path for generating route IDs
 * @param errorHandler - Error handler for client routes that renders errors via React Router
 * @returns A configured Hono application
 */
export function buildApp<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  serverRoute: Route<E, S, BasePath>,
  clientRoute: ClientRoute,
  reactHandlers: ReactHandlers,
  projectRoot?: string,
  parentPath: string = "/",
  errorHandler?: ErrorHandler,
): Hono<E, S, BasePath> {
  const notFound = createFactory().createMiddleware(() => {
    throw new HttpError(404, "Not found");
  });

  const isClientRoute = !!(
    clientRoute.main || clientRoute.index || clientRoute.catchall
  );

  function createClientRouteApp(
    serverMiddleware: Hono<E, S, BasePath> | undefined,
    currentRouteId: string,
    addHandlers: boolean,
  ): Hono<E, S, BasePath> {
    const routeApp = new Hono<E, S, BasePath>({ strict: true });

    if (errorHandler) {
      routeApp.onError(
        errorHandler as unknown as Parameters<typeof routeApp.onError>[0],
      );
    }

    routeApp.use(async (_c, next) => {
      await routeContextStorage.run(
        { routeId: currentRouteId, isClientRoute: true },
        async () => {
          await next();
        },
      );
    });

    if (serverMiddleware) {
      routeApp.route("/", serverMiddleware);
    }

    if (addHandlers) {
      routeApp.get("/", ...reactHandlers);
      routeApp.post("/", ...reactHandlers);
    }

    return routeApp;
  }

  function wrapServerOnlyApp(
    serverApp: Hono<E, S, BasePath>,
  ): Hono<E, S, BasePath> {
    const wrapper = new Hono<E, S, BasePath>({ strict: true });
    wrapper.onError(async (cause) => {
      const error = await convertToHttpError(cause);
      if (!error.instance) {
        const instance = getInstance();
        if (instance) {
          error.instance = instance;
        }
      }
      console.error(error);
      return error.getResponse();
    });
    wrapper.route("/", serverApp);
    return wrapper;
  }

  const routeId = parentPath;
  let app: Hono<E, S, BasePath>;

  if (isClientRoute && errorHandler) {
    const serverMiddleware = serverRoute.main?.default as
      | Hono<E, S, BasePath>
      | undefined;
    const addHandlers = !clientRoute.index && !!clientRoute.main;
    app = createClientRouteApp(serverMiddleware, routeId, addHandlers);
  } else if (serverRoute.main?.default) {
    app = wrapServerOnlyApp(serverRoute.main.default as Hono<E, S, BasePath>);
  } else {
    app = new Hono<E, S, BasePath>();
  }

  if (clientRoute.index || serverRoute.index) {
    const indexRouteId = generateRouteId(parentPath, "", "index");
    let indexApp: Hono<E, S, BasePath>;
    if (clientRoute.index && errorHandler) {
      const serverMiddleware = serverRoute.index?.default as
        | Hono<E, S, BasePath>
        | undefined;
      indexApp = createClientRouteApp(serverMiddleware, indexRouteId, true);
    } else if (serverRoute.index?.default) {
      indexApp = wrapServerOnlyApp(
        serverRoute.index.default as Hono<E, S, BasePath>,
      );
    } else {
      indexApp = new Hono<E, S, BasePath>();
    }
    app.route("/", indexApp);
  }

  const allChildPaths = new Set([
    ...(serverRoute.children || []).map((r) => r.path),
    ...(clientRoute.children || []).map((r) => r.path),
  ]);

  for (const childPath of allChildPaths) {
    const serverChild = serverRoute.children?.find((r) => r.path === childPath);
    const clientChild = clientRoute.children?.find((r) => r.path === childPath);

    if (serverChild || clientChild) {
      const childParentPath = generateRouteId(parentPath, childPath, "main");
      const childApp = buildApp(
        serverChild || { path: childPath as BasePath },
        clientChild || { path: childPath },
        reactHandlers,
        undefined,
        childParentPath,
        errorHandler,
      );
      app.route(`/${childPath}`, childApp);
    }
  }

  if (projectRoot) {
    const cwd = Deno.cwd();
    let publicPath = path.resolve(projectRoot, "./public");
    const relativePath = path.relative(cwd, publicPath);

    publicPath = Deno.build.os === "windows"
      ? relativePath.replace(/\\/g, "/")
      : relativePath;

    if (args["hot-reload"]) {
      const devClientPath = path.fromFileUrl(
        import.meta.resolve("./dev-client.js"),
      );
      const devClientContent = Deno.readTextFileSync(devClientPath);
      app.get("/dev-client.js", (c) => {
        return c.body(devClientContent, 200, {
          "Content-Type": "application/javascript",
        });
      });
    }

    app.get(
      "*",
      serveStatic({
        root: publicPath,
      }),
    );
  }

  if (clientRoute.catchall || serverRoute.catchall) {
    const catchallRouteId = generateRouteId(parentPath, "", "catchall");
    let catchallApp: Hono<E, S, BasePath>;
    if (clientRoute.catchall && errorHandler) {
      const serverMiddleware = serverRoute.catchall?.default as
        | Hono<E, S, BasePath>
        | undefined;
      catchallApp = createClientRouteApp(
        serverMiddleware,
        catchallRouteId,
        true,
      );
    } else if (serverRoute.catchall?.default) {
      catchallApp = wrapServerOnlyApp(
        serverRoute.catchall.default as Hono<E, S, BasePath>,
      );
    } else {
      catchallApp = new Hono<E, S, BasePath>();
    }
    app.route("/:*{.+}", catchallApp);
    app.route("*", catchallApp);
  }

  app.use("*", notFound);
  return app;
}
