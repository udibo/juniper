import * as path from "@std/path";
import { HttpError } from "@udibo/juniper";
import { Hono } from "hono";
import type { Schema, TypedResponse } from "hono";
import { trimTrailingSlash } from "hono/trailing-slash";
import type { RedirectStatusCode } from "hono/utils/http-status";
import { RouterContextProvider } from "react-router";

import type { Client } from "@udibo/juniper/client";
import { getInstance } from "@udibo/juniper/utils/otel";

import { buildApp, createHandlers, mergeServerRoutes } from "./_server.tsx";
import type { AppEnv, Route } from "./_server.tsx";

export type { AppEnv };

/**
 * Creates a Hono application server with the provided route configuration.
 * The main entrypoint that uses this function is automatically generated by the build script.
 *
 * This function sets up error handling, trailing slash trimming, static file serving,
 * and builds the complete route tree from the provided configuration, merging both
 * client and server routes.
 *
 * @example Creating an application
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 * import { client } from "./main.tsx";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ],
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @param moduleUrl - The URL of the module creating the server
 * @param client - The client configuration
 * @param routes - The server route configuration object
 * @returns A configured Hono application instance
 */
export function createServer<
  E extends AppEnv = AppEnv,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  moduleUrl: string,
  client: Client,
  route: Route<E, S, BasePath>,
): Hono<E, S, BasePath> {
  const projectRoot = path.dirname(path.fromFileUrl(moduleUrl));
  const appWrapper = new Hono<E, S, BasePath>({ strict: true });

  appWrapper.use(async (c, next) => {
    c.set("context", new RouterContextProvider());
    const originalRedirect = c.redirect;
    c.redirect = function redirect<T extends RedirectStatusCode = 302>(
      location: string | URL,
      status?: T,
    ): Response & TypedResponse<undefined, T, "redirect"> {
      if (c.req.header("X-Juniper-Route-Id")) {
        c.header("Vary", "Accept");
        c.header("X-Juniper", "redirect");
        return c.json({ location }) as unknown as
          & Response
          & TypedResponse<undefined, T, "redirect">;
      }
      return (originalRedirect<T>).call(c, location, status);
    };
    await next();
  });

  appWrapper.use(trimTrailingSlash());

  appWrapper.onError((cause) => {
    if (
      !(cause instanceof HttpError) &&
      cause !== null &&
      typeof cause === "object" &&
      "getResponse" in cause &&
      typeof cause.getResponse === "function"
    ) {
      console.error(cause);
      return cause.getResponse();
    }
    const error = HttpError.from(cause);
    if (!error.instance) {
      const instance = getInstance();
      if (instance) {
        error.instance = instance;
      }
    }
    console.error(error);
    return error.getResponse();
  });

  const serverRoutes = mergeServerRoutes(route, client.routeObjects);
  const { handlers, errorHandler } = createHandlers(route, serverRoutes);
  const app = buildApp(
    route,
    client.rootRoute,
    handlers,
    projectRoot,
    "0",
    errorHandler,
  );

  appWrapper.route("/", app);
  return appWrapper;
}
