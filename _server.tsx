import { HttpError } from "@udibo/http-error";
import type { Hono } from "hono";
import type { Env, Schema } from "hono";
import type { HydrationState } from "react-router";
import SuperJSON from "superjson";

import type { HydrationData, SerializedError } from "@udibo/juniper/client";
import { getInstance } from "@udibo/juniper/utils/otel";
import { isDevelopment } from "@udibo/juniper/utils/env";

import type {
  SerializedHydrationData,
  SerializedHydrationDataPromises,
} from "./_client.tsx";

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createServer } from "@udibo/juniper/server";
 * import { client } from "./main.tsx";
 *
 * export const server = createServer(import.meta.url, client, {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ],
 * });
 *
 * if (import.meta.main) {
 *   Deno.serve(server.fetch);
 * }
 * ```
 */
export interface Route<
  E extends Env = Env,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: {
    default?: Hono<E, S, BasePath>;
    serializeError?: (error: unknown) => SerializedError | unknown;
  };
  /** Optional index route handler (handles exact path matches) */
  index?: { default?: Hono<E, S, BasePath> };
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: { default?: Hono<E, S, BasePath> };
  /** Optional array of child routes */
  children?: Route<E, S, BasePath>[];
}

/**
 * Serializes an error to a serialized error.
 * The default serialize error function supports HttpError, Error, and global Error subclasses like TypeError.
 *
 * @param error - The error to serialize.
 * @returns The serialized error.
 */
export function serializeErrorDefault(
  error: unknown,
): SerializedError | unknown {
  let serializedError: SerializedError | unknown = error;
  if (error instanceof Error) {
    if (error instanceof HttpError) {
      if (!error.instance) error.instance = getInstance();
      serializedError = {
        __type: "Error",
        __subType: "HttpError",
        ...error.toJSON(),
      };
    } else {
      serializedError = { __type: "Error" };
      if (error.name !== "Error") {
        (serializedError as SerializedError).__subType = error.name;
      }
      (serializedError as SerializedError).message = error.message;
    }
    if (isDevelopment()) {
      (serializedError as SerializedError).stack = error.stack;
    }
  }
  return serializedError;
}

/**
 * Processes a single route data object, resolving any Promises and tracking
 * which keys were resolved or rejected for later reconstruction.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
async function processRouteData(
  routeData: Record<string, unknown>,
  serializeError?: (error: unknown) => unknown,
): Promise<{
  resolvedData: Record<string, unknown>;
  resolvedKeys: string[];
  rejectedKeys: string[];
}> {
  const resolvedData: Record<string, unknown> = {};
  const resolvedKeys: string[] = [];
  const rejectedKeys: string[] = [];

  for (const [key, value] of Object.entries(routeData)) {
    if (value instanceof Promise) {
      try {
        const resolvedValue = await Promise.resolve(value);
        resolvedData[key] = resolvedValue;
        resolvedKeys.push(key);
      } catch (error) {
        resolvedData[key] = serializeError?.(error) ??
          serializeErrorDefault(error);
        rejectedKeys.push(key);
      }
    } else {
      resolvedData[key] = value;
    }
  }

  return { resolvedData, resolvedKeys, rejectedKeys };
}

/**
 * Serializes hydration data by resolving all Promises and tracking their states.
 * Returns both the serialized data and metadata about which promises were resolved/rejected.
 * Uses custom serializeError function if provided, otherwise falls back to default.
 */
export async function serializeHydrationData(
  hydrationData: HydrationData,
  options: {
    serializeError?: (error: unknown) => unknown;
  } = {},
): Promise<SerializedHydrationData> {
  const { serializeError } = options;
  const resolved: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };
  const rejected: SerializedHydrationDataPromises = {
    loaderData: {},
    actionData: {},
  };

  const { matches } = hydrationData;

  // Serialize errors
  let errors: HydrationState["errors"];
  if (hydrationData.errors) {
    errors = {};
    for (const [key, serializedError] of Object.entries(hydrationData.errors)) {
      errors[key] = serializeError?.(serializedError) ??
        serializeErrorDefault(serializedError);
    }
  }

  // Process loader data
  let loaderData: HydrationState["loaderData"];
  if (hydrationData.loaderData) {
    loaderData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.loaderData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      loaderData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.loaderData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.loaderData![routeId] = rejectedKeys;
      }
    }
  }

  // Process action data
  let actionData: HydrationState["actionData"];
  if (hydrationData.actionData) {
    actionData = {};
    for (
      const [routeId, routeData] of Object.entries(hydrationData.actionData)
    ) {
      if (!routeData) continue;
      const { resolvedData, resolvedKeys, rejectedKeys } =
        await processRouteData(
          routeData,
          serializeError,
        );
      actionData[routeId] = resolvedData;

      if (resolvedKeys.length > 0) {
        resolved.actionData![routeId] = resolvedKeys;
      }
      if (rejectedKeys.length > 0) {
        rejected.actionData![routeId] = rejectedKeys;
      }
    }
  }

  const { json, meta } = SuperJSON.serialize({
    matches,
    errors,
    loaderData,
    actionData,
  });

  return {
    json,
    meta,
    resolved,
    rejected,
  };
}
