import type { Hono } from "hono";
import type { Env, Schema } from "hono";
import { HttpError } from "@udibo/http-error";
import { getInstance } from "@udibo/juniper/utils/otel";
import { isDevelopment } from "@udibo/juniper/utils/env";

import type {
  SerializedError,
  SerializedField,
  SerializedRouteData,
  SerializedRouteDataMap,
} from "./client.tsx";

/**
 * Configuration for a route in the Juniper routing system. These are automatically generated by the build script.
 *
 * @template E - Hono environment type
 * @template S - Hono schema type
 * @template BasePath - Base path string type
 *
 * @example Basic route configuration
 * ```ts
 * import { createApp } from "@udibo/juniper/server";
 *
 * const routes: Routes = {
 *   path: "/",
 *   main: await import("./routes/main.ts"),
 *   index: await import("./routes/index.ts"),
 *   children: [
 *     {
 *       path: "/api",
 *       main: await import("./routes/api/main.ts"),
 *       children: [
 *         {
 *           path: "/users",
 *           main: await import("./routes/api/users.ts"),
 *         }
 *       ]
 *     }
 *   ]
 * };
 * ```
 */
export interface Route<
  E extends Env = Env,
  S extends Schema = Schema,
  BasePath extends string = "/",
> {
  /** The URL path segment for this route */
  path: BasePath;
  /** Optional main route handler (typically used for middleware) */
  main?: {
    default?: Hono<E, S, BasePath>;
    serializeError?: (error: unknown) => SerializedError | unknown;
  };
  /** Optional index route handler (handles exact path matches) */
  index?: { default?: Hono<E, S, BasePath> };
  /** Optional catch-all route handler (handles unmatched paths) */
  catchall?: { default?: Hono<E, S, BasePath> };
  /** Optional array of child routes */
  children?: Route<E, S, BasePath>[];
}

export function serializeErrorDefault(
  error: unknown,
): SerializedError | unknown {
  let serializedError: SerializedError | unknown = error;
  if (error instanceof Error) {
    if (error instanceof HttpError) {
      if (!error.instance) error.instance = getInstance();
      serializedError = {
        __type: "Error",
        __subType: "HttpError",
        ...error.toJSON(),
      };
    } else {
      serializedError = { __type: "Error" };
      if (error.name !== "Error") {
        (serializedError as SerializedError).__subType = error.name;
      }
      (serializedError as SerializedError).message = error.message;
    }
    if (isDevelopment()) {
      (serializedError as SerializedError).stack = error.stack;
    }
  }
  return serializedError;
}

export async function serializeRouteData<
  E extends Env = Env,
  S extends Schema = Schema,
  BasePath extends string = "/",
>(
  route: Route<E, S, BasePath>,
  data: Record<string, unknown>,
): Promise<SerializedRouteDataMap> {
  const serializedRouteData: SerializedRouteDataMap = {};
  const serializeError = route.main?.serializeError ?? (() => {});
  for (const [id, routeData] of Object.entries(data)) {
    const __type = routeData instanceof Promise ? "Promise" : undefined;
    const serializedRouteDataEntry: SerializedRouteData = { __type };
    try {
      const resolvedData = await Promise.resolve(routeData);
      serializedRouteDataEntry.value = {};
      for (const [key, value] of Object.entries(resolvedData || {})) {
        const __type = value instanceof Promise ? "Promise" : undefined;
        const serializedField: SerializedField = { __type };
        try {
          const resolvedValue = await Promise.resolve(value);
          serializedField.value = resolvedValue;
        } catch (error) {
          serializedField.error = serializeError(error) ??
            serializeErrorDefault(error);
        }
        serializedRouteDataEntry.value![key] = serializedField;
      }
    } catch (error) {
      serializedRouteDataEntry.error = serializeError(error) ??
        serializeErrorDefault(error);
    }
    serializedRouteData[id] = serializedRouteDataEntry;
  }
  return serializedRouteData;
}
